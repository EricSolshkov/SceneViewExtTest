// Test project fo SceneViewExtension / RDG Shader Basic setup
// Copyright 2022 Ossi Luoto
// 
// Very basic Compute Shader utilizing the Engine basics

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "/Engine/Generated/GeneratedUniformBuffers.ush"

// Default border size for group.
#define DEFAULT_GROUP_BORDER_SIZE 8
#define GROUP_BORDER_SIZE (DEFAULT_GROUP_BORDER_SIZE)


// HeatSource Struct Definition
struct FSphereMeta
{
	float4x4 WorldToLocal;
	float Radius;
	float Temperature;
	float Thickness;
};

struct FBoxMeta
{
	float4x4 WorldToLocal;
	float3 XYZ;
	float Temperature;
	float Thickness;
};

struct FCapsuleMeta
{
	float4x4 WorldToLocal;
	float Radius;
	float HalfHeight;
	float Temperature;
	float Thickness;
};

// Parameters
uint4 ViewportRect;
StructuredBuffer<FSphereMeta> SphereHeatSources;
StructuredBuffer<FBoxMeta> BoxHeatSources;
StructuredBuffer<FCapsuleMeta> CapsuleHeatSources;
uint SphereCount;
uint BoxCount;
uint CapsuleCount;
float LowCut;
float HighCut;
float HalfValueDepth;
float3 CameraDirection;

Texture3D Noise;
SamplerState NoiseSampler;

Texture2D ColorStripe;
SamplerState ColorStripeSampler;

// We should be able to use View.BufferSizeAndInvSize here, but currently it is not possible/easy to get consistent results due to different scaling applications
float2 SceneColorBufferInvSize;
// Output
RWTexture2D<float4> Output;

// Reference method parameter
//float UVScale;

float CalcNoisedSphereMask(float3 WorldPosition, FSphereMeta Sphere)
{
	float4 HomoVec2Hit = mul(Sphere.WorldToLocal, float4(WorldPosition, 1));
	float3 Vec2Hit = HomoVec2Hit.xyz / HomoVec2Hit.w;
	const float3 Local1 = dot(Vec2Hit, Vec2Hit);
	const float Dist2Hit = sqrt(Local1).r;
	const float Dist2HitScaled = (Dist2Hit / Sphere.Radius);
	float RelativeRadiusClamp = (1.00000000 - Dist2HitScaled);
	RelativeRadiusClamp = max(min(RelativeRadiusClamp / (1 - Sphere.Thickness), 1), 0);

	const float3 ScaledWorldPosition = Vec2Hit.xyz / 256.0f;
	const float NoiseSample = Texture3DSample(Noise, NoiseSampler, ScaledWorldPosition).r;
	const float InvNoise = 1.0f - NoiseSample;
	const float ScaledInvNoise = InvNoise * 0.5f;

	float3 NoisedSphereMask = RelativeRadiusClamp - ScaledInvNoise;
	NoisedSphereMask = min(max(NoisedSphereMask, 0.00000000), 1.00000000);
	return NoisedSphereMask;
}

float CalcNoisedBoxMask(float3 WorldPosition, FBoxMeta Box)
{
	float4 HomoVec2Hit = mul(Box.WorldToLocal, float4(WorldPosition, 1));
	const float3 Vec2Hit = HomoVec2Hit.xyz / HomoVec2Hit.w;
	const float3 ScaledVec2Hit = abs(Vec2Hit) / Box.XYZ;
	const float3 Dist = (1 - ScaledVec2Hit);
	const float3 local0 = min(Dist.y, Dist.z);
	const float3 local1 = min(Dist.x, local0);
	float RelativeRadiusClamp = min(1, max(0, local1));
	RelativeRadiusClamp = max(min(RelativeRadiusClamp / (1 - Box.Thickness), 1), 0);

	const float3 ScaledWorldPosition = Vec2Hit.xyz / 256.0f;
	const float NoiseSample = Texture3DSample(Noise, NoiseSampler, ScaledWorldPosition).r;
	const float InvNoise = 1.0f - NoiseSample;
	const float ScaledInvNoise = InvNoise * 0.5f;

	float3 NoisedBoxMask = RelativeRadiusClamp - ScaledInvNoise;
	NoisedBoxMask = min(max(NoisedBoxMask, 0.00000000), 1.00000000);
	return NoisedBoxMask;
}

float CalcNoisedCapsuleMask(float3 WorldPosition, FCapsuleMeta Capsule)
{
	float4 HomoVec2Hit = mul(Capsule.WorldToLocal, float4(WorldPosition, 1));
	const float3 Vec2Hit = HomoVec2Hit.xyz / HomoVec2Hit.w;
	float Proj2Axis = abs(Vec2Hit.z) - Capsule.HalfHeight + Capsule.Radius;
	float ClampedProj = max(Proj2Axis, 0);
	float3 ClampedVec = float3(Vec2Hit.xy, ClampedProj);
	float3 ScaledClamped = ClampedVec / Capsule.Radius;
	float RelativeRadiusClamp = max(min(1 - sqrt(dot(ScaledClamped, ScaledClamped)), 1), 0);
	RelativeRadiusClamp = max(min(RelativeRadiusClamp / (1 - Capsule.Thickness), 1), 0);

	const float3 ScaledWorldPosition = Vec2Hit.xyz / 256.0f;
	const float NoiseSample = Texture3DSample(Noise, NoiseSampler, ScaledWorldPosition).r;
	const float InvNoise = 1.0f - NoiseSample;
	const float ScaledInvNoise = InvNoise * 0.5f;

	float3 NoisedCapsuleMask = RelativeRadiusClamp - ScaledInvNoise;
	NoisedCapsuleMask = min(max(NoisedCapsuleMask, 0.00000000), 1.00000000);
	return NoisedCapsuleMask;
}

// Compute Shader code
[numthreads(GROUP_BORDER_SIZE, GROUP_BORDER_SIZE, 1)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	// Check that we are in scope
	if (any(DispatchThreadId >= ViewportRect.zw))
	{
		return;
	}
	ViewState ResolvedView = ResolveView();

	// If we have the Original Scene Color still here, we need to use the original offset as well
	// Due to UniformBuffer refering to the Viewport before TAA (this might change in the future?) we need to apply scale to the UV
	float2 sampleUV = (float2(View.ViewRectMin.xy) + (DispatchThreadId + 0.5)) * SceneColorBufferInvSize;

	// Another method here for referene - scaling introduced in 5.0> made it super difficult to get consistent results
	// float2 sampleUV = (float2(View.ViewRectMin.xy) + (DispatchThreadId + 0.5)) * View.BufferSizeAndInvSize.zw * UVScale;

	// Load GBuffer
	FGBufferData GBuffer = DecodeGBufferData(
		SceneTexturesStruct.GBufferATexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.GBufferBTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.GBufferCTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.GBufferDTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.GBufferETexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.GBufferFTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.GBufferVelocityTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.CustomDepthTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.CustomStencilTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		SceneTexturesStruct.SceneDepthTexture.SampleLevel(GlobalPointClampedSampler, sampleUV, 0),
		true, true
	);

	// Calc world position
	const float4 SvPosition = float4(DispatchThreadId, GBuffer.Depth, 1.0f);
	float4 AbsoluteWorldPosition = float4(SvPositionToWorld(SvPosition), 1.0f);
	
	float Temperature = 0;
	for (int i = 0; i < SphereCount; ++i)
	{
		float3 NoisedSphereMask = CalcNoisedSphereMask(
			AbsoluteWorldPosition.xyz,
			SphereHeatSources[i]);
		
		float EquivalentTemperature =
			(Pow4(SphereHeatSources[i].Temperature + 273) - Pow4(LowCut + 273)) /
			(Pow4(HighCut + 273) - Pow4(LowCut + 273));
		Temperature = max(Temperature, lerp(GBuffer.BaseColor, EquivalentTemperature, NoisedSphereMask));
	}
	for (int i = 0; i < BoxCount; ++i)
	{
		float3 NoisedBoxMask = CalcNoisedBoxMask(
			AbsoluteWorldPosition.xyz,
			BoxHeatSources[i]);
		
		float EquivalentTemperature =
			(Pow4(BoxHeatSources[i].Temperature + 273) - Pow4(LowCut + 273)) /
			(Pow4(HighCut + 273) - Pow4(LowCut + 273));
		Temperature = max(Temperature, lerp(GBuffer.BaseColor, EquivalentTemperature, NoisedBoxMask));
	}
	for (int i = 0; i < CapsuleCount; ++i)
	{
		float3 NoisedCapsuleMask = CalcNoisedCapsuleMask(
			AbsoluteWorldPosition.xyz,
			CapsuleHeatSources[i]);
		
		float EquivalentTemperature =
			(Pow4(CapsuleHeatSources[i].Temperature + 273) - Pow4(LowCut + 273)) /
			(Pow4(HighCut + 273) - Pow4(LowCut + 273));
		Temperature = max(Temperature, lerp(GBuffer.BaseColor, EquivalentTemperature, NoisedCapsuleMask));
	}
	
	float HeatedBaseRG = (GBuffer.BaseColor.r + GBuffer.BaseColor.g);
	float HeatedBaseSum = (HeatedBaseRG + GBuffer.BaseColor.b);
	float HeatedBase01 = (HeatedBaseSum / 3.00000000);
	float HeatedBaseColor = Temperature + HeatedBase01;
	float4 MappedHeatedColor = Texture2DSample(ColorStripe, ColorStripeSampler, float2(HeatedBaseColor, 0.50000000));

	// Distance/Depth Decay
	float InvDvcDepth = 1 / GBuffer.Depth;
	float TrueDepth = InvDvcDepth - 1.00000000;
	float ScaledTrueDepth = TrueDepth / HalfValueDepth;
	ScaledTrueDepth = ScaledTrueDepth + 1.00000000;
	float DepthDecay = 1 / (ScaledTrueDepth * ScaledTrueDepth);
	DepthDecay = sqrt(DepthDecay);

	// Fake AO Decay
	float TowardOutsideScreen = abs(dot(GBuffer.WorldNormal, CameraDirection));
	float Temp0 = (TowardOutsideScreen + 7.00000000);
	float AODecay = (Temp0 / 8.00000000);
	float FinalDecay = (DepthDecay * AODecay);

	// Final decay.
	float4 DecayedHeat = float4(MappedHeatedColor.rgb * FinalDecay, 1);
	Output[View.ViewRectMin.xy + DispatchThreadId] = 1 - Pow3(1 - DecayedHeat);
	//Output[View.ViewRectMin.xy + DispatchThreadId] = float4(HeatedBaseColor,HeatedBaseColor,HeatedBaseColor,1);
}
